# Coding in Humanities - Course Development

This repository is a collection of ideas and an initial framework for teaching coding techniques to Humanities students. The main purpose is to be able to identify tasks that can be automated, break down those tasks into smaller ones, and solve them using programming techniques. The information proposed here is largely a guideline on how to approach these problems and set up a working plan of action to solve them. It is therefore irrelevant which programming language is used, the concepts are universal.

# Course Modules
## Technical
## 1. Basics - from the real world to the digital world
### Introduction
This module has been designed to help you understand the basic idea behind 'computational thinking' i.e. thinking in a way that helps to logically solve problems. This type of thinking is fundamental to being able to write code and solve computational problems.
### Content
How computers process instructions - peanut butter sandwich [https://www.youtube.com/watch?v=Ct-lOOUqmyY](https://www.youtube.com/watch?v=Ct-lOOUqmyY)

When a person thinks about what programming is, they often think about writing strange characters onto a black screen and seeing a waterfall of green coding snippets fill the screen - like in the movie "The Matrix". Quite disappointingly, this isn't what programming is. Programming, in a nutshell, is solving a problem then converting that solution into something a machine (computer) can understand. In fact we do programming every day, we just don't realize it. The purpose of these five modules is to provide you with the tools to convert real-world problems into computational problems then solve them using a programming language. You might be curious to know where you have been using programming in your daily life, so below is an example of that.

Imagine it's a Monday morning and you have a class starting at 09:00 at the university. You arrive at the university at 08:45 - in time to grab a cup of coffee. There are two coffee shops on campus (Coffee Shop A and Coffee Shop B) - you prefer Coffee Shop A, but the lines are usually quite long. So you tell yourself, if there are 4 or fewer people in the line at Coffee Shop A then you'll wait in line, but if there are more then you will go to Coffee Shop B. This is a very simple example of a if-statement in programming, so congratulations, you've just done some programming!

### Explanation of independence
There is no "know-all" guide to programming because each problem has a unique set of difficulties. If this weren't the case then you could just use a program someone else has already written. In many cases, you will use parts of other people's code, but the changes you make are unique to the use case you have. So, one of the most important aspects of programming is to be able to work independently and collaboratively. The independent aspect is mostly centered around being able to visualize what your solution is going to be. You need to understand the problem, develop a plan to solve it, and be able to communicate this to other people. In order to do this, you have to learn to develop an independent way of thinking.  

This may seem counterintuitive, so here is a practical example. Imagine that you have a real-world problem, but you cannot ask any one person for help until you have your own solution. What will be the first steps you take? The first steps would be to develop your own solution. Again, this might sound very trivial, since aren't you asking for help because you can't find a solution? Most of the time, this is not the case. Most of the time people ask for help because they don't know where to start, so this forces you to do something. If you can start with a solution, it doesn't matter how bad it might be, it will give the person you are asking the question to a glimpse into your mind. This will make it easier for them to be able to understand your way of thinking. The easier it is for them to understand what you are thinking, the easier it is for them to offer real, productive advice. 

Let's dive a little deeper into this example. What are the kinds of questions you could ask when trying to understand a real-world problem? For example, if I have to create a program that finds all the verbs in a document, I need to know where to start. Let's assume no-one can help me until I have my own suggestion, so I need to come up with an initial idea.

***Initial Idea***

Find out what tools I have available.
I'm using the Python programming language and I have a folder with 100 documents. 

Search for some quick answers.
I search on Google "how can I get access to a document's words in python". This gives me a lot of search results about opening Microsoft Word documents in Python. This is not exactly what I need because the documents I have are actually text files, so I try a new search "how can I get access to a text file in python". This gives me some results.

### Explanation of finding answers
Inline with the previous section, the goal is to be able to find the correct answers.  Often perceptions of what programming make it out to be more intimidating than it actually is. The truth is that programming is made up of very small snippets of code that all work together. It is therefore important to make your search queries as concise and specific as possible, so that you are able to understand the small code snippets. How does this look in practice? Let's take a look at the following example.

The first search result from Google for the query "how can I get access to a text file in python" was the following website (as of 18 March 2022, this could be different depending on the date) https://www.pythontutorial.net/python-basics/python-read-text-file/ and looking at the explanations on the website, they go into detail on how to open files in Python. That is a simple way to find answers.

**Vetting results**

Now that you are able to find some ways in which to solve the problems, the next step is too see whether those results are the best that you can find. One way to do this is to find at least 3 different sites that provide solutions to the problem, compare them and choose the one with the least amount of steps required. A good rule of thumb is to avoid any unnecessary installations, code that is unreasonably long or code that you don't understand at all. A lot of the time, you will find code that could contain parts which are unfamiliar to you. If you don't understand anything written in the code, then it would be beneficial to break that solution down and figure out how each component of the solution works. This will help you to understand if the code is what you were looking for.

**Practical Exercise**

## 2. What will the program do - thinking like a computer

### Introduction
When programming, the computer will follow your instructions 100% literally. This means that it's not uncommon for a single semi-colon or a capital letter to break the flow of a program. It is important to imagine how a computer would process the instructions you are giving it. In this way you can find errors easier and be able to fix them

Key to thinking like a programmer [https://www.youtube.com/watch?v=vrmKwQ-JPTA](https://www.youtube.com/watch?v=vrmKwQ-JPTA)

### Create expectations of what the code should do
### Identifying your own assumptions which the computer doesn't know

## Practical
## 3. Identifying real-world problems
### Introduction
**IPO tables:** 
1. **Input** - establish thinking around data types
	-	Practical: determine what your input is and what data type it is.
2.  **Processing** - establish thinking around what you expect the program to do
	-	Practical: determine what you want to do with your input.
3.  **Output** - establish thinking about what you expect to get out
	-	Practical: determine how you want you input to be at the end of the process.

### Break the problems down into smaller pieces
### Turn those pieces into control flows

## 4. Finding solutions - turning pseudocode into runnable code
### Introduction
**Finding answers to questions** 
In most cases, the answers you find to questions you are searching for will be sufficient, but not exact. Finding answers is about finding something that works similar to what you are building, then tweaking it to fit your use case. 

### Match current tech to your control flow steps
### Effective use of information gathering 
**Errors are not failures, but indications that something went wrong. They are also breadcrumbs to follow to find the solution**
**Can you reproduce the errors in isolation**

## 5. Optimizing code - producing better and more efficient solutions.
### Introduction
### Finding and following best practices
### How to know what or when to optimize

## Additional Examples Module
**Examples**
1. I am an historian and I need to go through 3000 documents to find specific people and list the sentences their names appear in. I can then read through those sentences manually to find which ones are relevant to my research.
	-  Input
	    -  	Find the data i.e. where is it located? Can you access it?
	    -   In which format is the data i.e. text files, pdfs, physical books?
    -   Processing
	    -   Read the files
	    -   Split the files into sentences
	    -   Loop through each sentence and save those which have the name to a list
    - Output
	    - Save those lists to a file which can be read or printed out
  2. Iâ€™m a linguist and I need to extract all the verbs from a document, count them and display the top 10 occurring verbs. I will use these top 10 verbs to determine what the document is about.
		- Input
			-    Find the document i.e. where is located?
			-   Determine what file type the document is.
		- Processing
			-   Read the contents of the document
			-   Separate all the words
			-   Filter out anything that is not a verb
			-   Count the remaining verbs
			-   Sort them from most frequency to least frequent
		- Output
			- Display the top 10 elements of the sorted list

# Resources

Python for Digital Humanities channel [https://www.youtube.com/playlist?list=PL2VXyKi-KpYuy_7p4nSE2z0535FDky5zA](https://www.youtube.com/playlist?list=PL2VXyKi-KpYuy_7p4nSE2z0535FDky5zA)

Problem solve like a programmer [https://www.youtube.com/watch?v=x77-gT8bWLo](https://www.youtube.com/watch?v=x77-gT8bWLo)
